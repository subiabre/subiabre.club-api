<?php

namespace App\Service;

use App\Entity\User;
use App\Entity\UserKey;
use App\Entity\UserSession;
use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Symfony\Component\HttpFoundation\Cookie;
use Symfony\Component\HttpFoundation\Session\Session;
use Symfony\Component\HttpFoundation\Session\SessionUtils;

class AuthenticationService
{
    public const CONFIG_SESSION_LIFETIME = 'session_lifetime';
    public const CONFIG_CORS_ALLOW_ORIGIN = 'allow_origin';

    private array $config;

    public function __construct(
        string $allowOrigin,
        string $sessionLifetime,
        private string $appSecret,
    ) {
        $this->config = [
            self::CONFIG_CORS_ALLOW_ORIGIN => $allowOrigin,
            self::CONFIG_SESSION_LIFETIME => $sessionLifetime
        ];
    }

    public function getConfig(): array
    {
        return $this->config;
    }

    /**
     * Generates a SHA-256 hash from the `APP_SECRET` + `$data` + random_bytes
     * @param array $data The data to be included in the hash
     * @return string
     */
    public function hashWithSecret(array $data = []): string
    {
        return hash(
            'sha256',
            join('', [
                $this->appSecret,
                ...$data,
                random_bytes(32)
            ])
        );
    }

    /**
     * Generates a JWT that can authenticate a User
     * @param User $user The User resource that will be authenticated with this token
     * @param int|null $exp The optional lifetime of this token
     * @return string The JWT
     */
    public function createUserSessionToken(User $user, ?int $lifetime): string
    {
        return JWT::encode(
            array_merge([
                'user' => $user->getId(),
            ], array_filter([
                'exp' => $lifetime ? (new \DateTime(sprintf('+%d seconds', $lifetime)))->getTimestamp() : $lifetime,
            ])),
            $this->appSecret,
            'HS256'
        );
    }

    /**
     * Validates a JWT generated by this same service
     * @param string $token The token to be validated
     * @return array The JWT data as an array
     * 
     * @throws InvalidArgumentException     Provided key/key-array was empty or malformed
     * @throws DomainException              Provided JWT is malformed
     * @throws UnexpectedValueException     Provided JWT was invalid
     * @throws SignatureInvalidException    Provided JWT was invalid because the signature verification failed
     * @throws BeforeValidException         Provided JWT is trying to be used before it's eligible as defined by 'nbf'
     * @throws BeforeValidException         Provided JWT is trying to be used before it's been created as defined by 'iat'
     * @throws ExpiredException             Provided JWT has since expired, as defined by the 'exp' claim
     */
    public function validateUserSessionToken(string $token): array
    {
        return (array) JWT::decode(
            $token,
            new Key($this->appSecret, 'HS256')
        );
    }

    /**
     * Invalidates a specific session without invalidating the currently active session
     * @param string $id The id of the session to be invalidated
     */
    public function invalidateSession(string $id): void
    {
        $session = new Session();
        $currentId = $session->getId();

        $session->save();
        $session->setId($id);
        $session->start();
        $session->invalidate();

        /**
         * Symfony\Component\HttpFoundation\Session\Session::invalidate() will set the session cookie as 'deleted'
         * So we avoid that because we don't really wan't to log out the user
         */
        SessionUtils::popSessionCookie($session->getName(), 'deleted');

        $session->save();
        $session->setId($currentId);
        $session->start();
    }

    /**
     * Creates a session `Cookie` with the expiration date refreshed
     * @param Session $session
     * @return Cookie New `Cookie` to be sent in the `Response` headers
     */
    public function refreshCookie(Session $session): Cookie
    {
        return new Cookie(
            name: $session->getName(),
            value: $session->getId(),
            expire: time() + $this->config[self::CONFIG_SESSION_LIFETIME],
            path: '/',
            httpOnly: true,
            sameSite: 'lax',
            domain: $this->config[self::CONFIG_CORS_ALLOW_ORIGIN]
        );       
    }

    /**
     * Updates a `UserSession` to expire in the current date + the session cookie lifetime
     * @param UserSession
     * @return UserSession|null
     */
    public function refreshUserSession(?UserSession $userSession): ?UserSession
    {
        return $userSession->setDateExpires(
            new \DateTime(sprintf('+%s seconds', $this->config[self::CONFIG_SESSION_LIFETIME]))
        );
    }
}
